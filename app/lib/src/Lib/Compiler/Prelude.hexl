--------------------------------------------------------------------------------
-- Function

id : forall a. a -> a
id x = x

const : forall a b. b -> a -> b
const c _ = c

flip : forall a b c. (a -> b -> c) -> b -> a -> c
flip f b a = f a b

apply : forall a b. (a -> b) -> a -> b
apply f x = f x

infixr 0 apply as <|

applyFlipped : forall a b. a -> (a -> b) -> b
applyFlipped x f = f x

infixl 1 applyFlipped as |>

--------------------------------------------------------------------------------
-- Boolean

type Boolean
  = True
  | False

conj : Boolean -> Boolean -> Boolean
conj x y = if x then y else False

infixr 3 conj as &&

disj : Boolean -> Boolean -> Boolean
disj x y = if x then True else y

infixr 2 disj as ||

not : Boolean -> Boolean
not x = if x then False else True

--------------------------------------------------------------------------------
-- Num

class Num x where
  add : x -> x -> x
  sub : x -> x -> x
  mul : x -> x -> x
  div : x -> x -> x
  one : x
  zero : x

infixl 6 add as +
infixl 6 sub as -
infixl 7 mul as *
infixl 7 div as /

instance Num Integer where
  add = prim_addInteger
  sub = prim_subInteger
  mul = prim_mulInteger
  div = prim_divInteger
  one = 1
  zero = 0

instance Num Number where
  add = prim_addNumber
  sub = prim_subNumber
  mul = prim_mulNumber
  div = prim_divNumber
  one = 1.0
  zero = 0.0

roundTo : Integer -> Number -> Number
roundTo = prim_roundTo

--------------------------------------------------------------------------------
-- Eq

class Eq a where
  eq : a -> a -> Boolean

infix 4 eq as ==

instance Eq Integer where
  eq = prim_eqInteger

instance Eq Number where
  eq = prim_eqNumber

instance Eq String where
  eq = prim_eqString

instance Eq DateTime where
  eq = prim_eqDateTime

instance Eq (Row t) where
  eq = prim_eqRow

instance Eq Boolean where
  eq x y = case Tuple x y of
    Tuple True True   -> True
    Tuple False False -> True
    _                 -> False

notEq : forall a. Eq a => a -> a -> Boolean
notEq a b = not <| a == b

infix 4 notEq as /=

--------------------------------------------------------------------------------
-- Ordering

type Ordering
  = EQ
  | LT
  | GT

class Eq a => Ord a where
  compare : a -> a -> Ordering

instance Ord Number where
  compare = prim_compareNumber

instance Ord Integer where
  compare = prim_compareInteger

instance Ord DateTime where
  compare = prim_compareDateTime

lessThan : forall a. Ord a => a -> a -> Boolean
lessThan a b = case compare a b of
  LT -> True
  _  -> False

infixl 4 lessThan as <

greaterThan : forall a. Ord a => a -> a -> Boolean
greaterThan a b = case compare a b of
  GT -> True
  _  -> False

infixl 4 greaterThan as >

lessThanOrEq : forall a. Ord a => a -> a -> Boolean
lessThanOrEq a b = case compare a b of
  GT -> False
  _  -> True

infixl 4 lessThanOrEq as <=

greaterThanOrEq : forall a. Ord a => a -> a -> Boolean
greaterThanOrEq a b = case compare a b of
  LT -> False
  _  -> True

infixl 4 greaterThanOrEq as >=

min : forall a. Ord a => a -> a -> a
min a b = if a > b then b else a

max : forall a. Ord a => a -> a -> a
max a b = if a < b then b else a

--------------------------------------------------------------------------------
-- Data.Tuple

type Tuple a b = Tuple a b

instance Eq a => Eq b => Eq (Tuple a b) where
  eq (Tuple a b) (Tuple a' b') = a == a' && b == b'

--------------------------------------------------------------------------------
-- Data.List

type List a
  = Nil
  | Cons a (List a)

instance Eq a => Eq (List a) where
  eq xs ys = case Tuple xs ys of
    Tuple Nil Nil                 -> True
    Tuple (Cons a as) (Cons b bs) -> a == b && as == bs
    _                             -> False

member : forall a. Eq a => a -> List a -> Boolean
member x xs = case xs of
  Nil -> False
  Cons a as -> if x == a then True else member x as

sum : forall a. Num a => List a -> a
sum xs = case xs of
  Nil -> zero
  Cons a as -> a + sum as

length : forall a. List a -> Integer
length xs = case xs of
  Nil -> 0
  Cons _ as -> 1 + length as

filter : forall a. (a -> Boolean) -> List a -> List a
filter p xs = case xs of
  Nil -> Nil
  Cons a as ->
    let
      as' = filter p as
    in
      if p a then Cons a as' else as'

find : forall a. (a -> Boolean) -> List a -> Maybe a
find p xs = case xs of
  Nil -> Nothing
  Cons a as -> if p a then Just a else find p as

--------------------------------------------------------------------------------
-- Data.Maybe

type Maybe a
  = Nothing
  | Just a

instance Eq a => Eq (Maybe a) where
  eq ma mb = case Tuple ma mb of
    Tuple Nothing Nothing   -> True
    Tuple (Just a) (Just b) -> a == b
    _                       -> False

maybe : forall a b. b -> (a -> b) -> Maybe a -> b
maybe def f ma = case ma of
  Nothing -> def
  Just a -> f a

fromMaybe : forall a. a -> Maybe a -> a
fromMaybe def = maybe def id

--------------------------------------------------------------------------------
-- Data.Either

type Either a b
  = Left a
  | Right b

instance Eq a => Eq b => Eq (Either a b) where
  eq e e' = case Tuple e e' of
    Tuple (Left a) (Left a')   -> a == a'
    Tuple (Right b) (Right b') -> b == b'
    _                          -> False

either : forall a b c. (a -> c) -> (b -> c) -> Either a b -> c
either f g e = case e of
  Left a  -> f a
  Right b -> g b

--------------------------------------------------------------------------------
-- Functor

class Functor f where
  map : forall a b. (a -> b) -> f a -> f b

instance Functor List where
  map f xs = case xs of
    Nil -> Nil
    Cons a as -> Cons (f a) (map f as)

instance Functor Maybe where
  map f ma = case ma of
    Nothing -> Nothing
    Just a -> Just (f a)

instance Functor (Either a) where
  map f e = case e of
    Left a -> Left a
    Right b -> Right (f b)

--------------------------------------------------------------------------------
-- Semigroup

class Semigroup a where
  append : a -> a -> a

infixr 5 append as <>

instance Semigroup (List a) where
  append xs ys = case xs of
    Nil -> ys
    Cons a as -> Cons a (as <> ys)

instance Semigroup String where
  append = prim_appendString

--------------------------------------------------------------------------------
-- Print

class Print a where
  print : a -> String

instance Print Boolean where
  print x = if x then "True" else "False"

instance Print Integer where
  print = prim_printInteger

instance Print Number where
  print = prim_printNumber

instance Print String where
  print = id

--------------------------------------------------------------------------------
-- Formatting

formatNumber : String -> Number -> String
formatNumber = prim_formatNumber

formatDateTime : String -> DateTime -> String
formatDateTime = prim_formatDateTime

--------------------------------------------------------------------------------
-- DateTime

year : DateTime -> Integer
year = prim_year

month : DateTime -> Integer
month = prim_month

day : DateTime -> Integer
day = prim_day
